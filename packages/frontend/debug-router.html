<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Router è°ƒè¯•é¡µé¢</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .section {
      margin-bottom: 30px;
      padding: 20px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #fafafa;
    }
    .debug-info {
      background: #e8f4f8;
      padding: 15px;
      border-radius: 4px;
      margin: 10px 0;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .error { background: #ffe6e6; border-color: #ffaaaa; }
    .success { background: #e8f5e8; border-color: #aaffaa; }
    .warning { background: #fff4e6; border-color: #ffddaa; }
    button {
      background: #007cba;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #005a87; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ” React Router & Desktop æ¸²æŸ“è°ƒè¯•å·¥å…·</h1>
    
    <div class="section">
      <h2>1. ç¯å¢ƒæ£€æµ‹</h2>
      <div id="env-check" class="debug-info">æ£€æµ‹ä¸­...</div>
    </div>
    
    <div class="section">
      <h2>2. DOM ç»“æ„åˆ†æ</h2>
      <button onclick="analyzeDOMStructure()">åˆ†æDOMç»“æ„</button>
      <div id="dom-analysis" class="debug-info">ç­‰å¾…åˆ†æ...</div>
    </div>
    
    <div class="section">
      <h2>3. React Router çŠ¶æ€</h2>
      <button onclick="checkReactRouter()">æ£€æŸ¥RouterçŠ¶æ€</button>
      <div id="router-status" class="debug-info">ç­‰å¾…æ£€æŸ¥...</div>
    </div>
    
    <div class="section">
      <h2>4. API è¿æ¥æµ‹è¯•</h2>
      <button onclick="testAPIConnection()">æµ‹è¯•APIè¿æ¥</button>
      <div id="api-test" class="debug-info">ç­‰å¾…æµ‹è¯•...</div>
    </div>
    
    <div class="section">
      <h2>5. ç”Ÿæˆè¯Šæ–­æŠ¥å‘Š</h2>
      <button onclick="generateReport()">ç”Ÿæˆå®Œæ•´æŠ¥å‘Š</button>
      <div id="full-report" class="debug-info">ç­‰å¾…ç”Ÿæˆ...</div>
    </div>
  </div>

  <script>
    // ç¯å¢ƒæ£€æµ‹
    function checkEnvironment() {
      const info = {
        userAgent: navigator.userAgent,
        isElectron: typeof window.electronAPI !== 'undefined',
        location: window.location,
        hasReact: typeof window.React !== 'undefined',
        hasReactDOM: typeof window.ReactDOM !== 'undefined',
        hasRouter: typeof window.ReactRouter !== 'undefined',
        consoleErrors: [],
        timestamp: new Date().toISOString()
      };
      
      document.getElementById('env-check').textContent = JSON.stringify(info, null, 2);
      return info;
    }
    
    // DOMç»“æ„åˆ†æ
    function analyzeDOMStructure() {
      try {
        const rootElement = document.getElementById('root');
        const analysis = {
          hasRoot: !!rootElement,
          rootChildren: rootElement ? rootElement.children.length : 0,
          rootHTML: rootElement ? rootElement.innerHTML.substring(0, 500) + '...' : 'Not found',
          titleBarExists: !!document.querySelector('.h-8.bg-\\[\\#2f2f2f\\]'),
          layoutExists: !!document.querySelector('[class*="min-h-screen"]'),
          outletExists: !!document.querySelector('[data-testid="outlet"]') || checkForOutletPattern(),
          mainContentExists: !!document.querySelector('main'),
          routerProviderExists: checkForReactRouterProvider()
        };
        
        document.getElementById('dom-analysis').textContent = JSON.stringify(analysis, null, 2);
        return analysis;
      } catch (error) {
        const errorInfo = { error: error.message, stack: error.stack };
        document.getElementById('dom-analysis').textContent = JSON.stringify(errorInfo, null, 2);
        return errorInfo;
      }
    }
    
    function checkForOutletPattern() {
      // æ£€æŸ¥æ˜¯å¦æœ‰ç±»ä¼¼Outletçš„å…ƒç´ æ¨¡å¼
      const elements = document.querySelectorAll('*');
      let hasOutletPattern = false;
      elements.forEach(el => {
        if (el.textContent && el.textContent.includes('Outlet')) {
          hasOutletPattern = true;
        }
      });
      return hasOutletPattern;
    }
    
    function checkForReactRouterProvider() {
      // æ£€æŸ¥React Router Provideræ˜¯å¦å­˜åœ¨
      return window.location.pathname !== undefined && 
             (typeof window.history !== 'undefined');
    }
    
    // React RouterçŠ¶æ€æ£€æŸ¥
    function checkReactRouter() {
      try {
        const routerInfo = {
          currentPath: window.location.pathname,
          currentHash: window.location.hash,
          currentSearch: window.location.search,
          historyLength: window.history.length,
          hasHistoryAPI: typeof window.history.pushState !== 'undefined',
          reactDevToolsPresent: typeof window.__REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined'
        };
        
        // å°è¯•æ£€æµ‹Reactåº”ç”¨çŠ¶æ€
        if (window.React && window.React.version) {
          routerInfo.reactVersion = window.React.version;
        }
        
        document.getElementById('router-status').textContent = JSON.stringify(routerInfo, null, 2);
        return routerInfo;
      } catch (error) {
        const errorInfo = { error: error.message };
        document.getElementById('router-status').textContent = JSON.stringify(errorInfo, null, 2);
        return errorInfo;
      }
    }
    
    // APIè¿æ¥æµ‹è¯•
    async function testAPIConnection() {
      try {
        // æµ‹è¯•å¤šä¸ªå¯èƒ½çš„åç«¯ç«¯å£
        const testPorts = [3000, 3001, 3002];
        const results = [];
        
        for (const port of testPorts) {
          try {
            const response = await fetch(`http://localhost:${port}/api/v1/health`, {
              method: 'GET',
              headers: { 'Content-Type': 'application/json' },
              timeout: 5000
            });
            
            results.push({
              port: port,
              status: response.status,
              ok: response.ok,
              data: response.ok ? await response.json() : null
            });
          } catch (err) {
            results.push({
              port: port,
              error: err.message,
              status: 'failed'
            });
          }
        }
        
        document.getElementById('api-test').textContent = JSON.stringify(results, null, 2);
        return results;
      } catch (error) {
        const errorInfo = { error: error.message };
        document.getElementById('api-test').textContent = JSON.stringify(errorInfo, null, 2);
        return errorInfo;
      }
    }
    
    // ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
    async function generateReport() {
      const report = {
        timestamp: new Date().toISOString(),
        environment: checkEnvironment(),
        domAnalysis: analyzeDOMStructure(),
        routerStatus: checkReactRouter(),
        apiTest: await testAPIConnection(),
        consoleErrors: getConsoleErrors(),
        recommendations: []
      };
      
      // æ·»åŠ å»ºè®®
      if (!report.domAnalysis.outletExists) {
        report.recommendations.push("ä¸»å†…å®¹åŒºåŸŸç¼ºå¤± - å¯èƒ½æ˜¯React Routerçš„Outletç»„ä»¶æœªæ­£ç¡®æ¸²æŸ“");
      }
      
      if (!report.apiTest.some(test => test.ok)) {
        report.recommendations.push("APIè¿æ¥å¤±è´¥ - åç«¯æœåŠ¡å¯èƒ½æœªå¯åŠ¨æˆ–ç«¯å£é…ç½®é”™è¯¯");
      }
      
      if (!report.environment.isElectron) {
        report.recommendations.push("éElectronç¯å¢ƒ - åœ¨æµè§ˆå™¨ä¸­æµ‹è¯•å¯èƒ½ä¸Desktopåº”ç”¨è¡Œä¸ºä¸åŒ");
      }
      
      document.getElementById('full-report').textContent = JSON.stringify(report, null, 2);
      return report;
    }
    
    // è·å–æ§åˆ¶å°é”™è¯¯
    function getConsoleErrors() {
      // è¿™ä¸ªå‡½æ•°éœ€è¦åœ¨é¡µé¢åŠ è½½å‰è®¾ç½®æ‰èƒ½æ•è·æ‰€æœ‰é”™è¯¯
      return window.consoleErrors || [];
    }
    
    // æ•è·æ§åˆ¶å°é”™è¯¯
    window.consoleErrors = [];
    const originalConsoleError = console.error;
    console.error = function(...args) {
      window.consoleErrors.push({
        timestamp: new Date().toISOString(),
        message: args.join(' ')
      });
      originalConsoleError.apply(console, args);
    };
    
    // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨æ‰§è¡Œç¯å¢ƒæ£€æµ‹
    document.addEventListener('DOMContentLoaded', function() {
      checkEnvironment();
    });
  </script>
</body>
</html>