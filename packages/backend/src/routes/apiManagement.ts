import express from 'express';
import { z } from 'zod';
import { APIEndpointService } from '../services/api/APIEndpointService';
import { APIGroupService } from '../services/api/APIGroupService';
import { SyncService } from '../services/api/SyncService';
import { validateRequest } from '../middleware/zodValidation';
import { prisma } from '../lib/prisma';
import logger from '../utils/logger';

const router = express.Router();

// 初始化服务
const endpointService = new APIEndpointService(prisma);
const groupService = new APIGroupService(prisma);
const syncService = new SyncService(prisma);

// ==================== API端点路由 ====================

// 创建API端点
const createEndpointSchema = z.object({
  body: z.object({
    projectId: z.string().uuid(),
    groupId: z.string().uuid().optional(),
    name: z.string().min(1).max(100),
    displayName: z.string().max(200).optional(),
    method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']),
    path: z.string().min(1).max(500),
    summary: z.string().max(200).optional(),
    description: z.string().max(2000).optional(),
    tags: z.array(z.string()).optional(),
    deprecated: z.boolean().optional(),
    version: z.string().max(20).optional(),
    authRequired: z.boolean().optional(),
    authType: z.string().max(50).optional(),
    scopes: z.array(z.string()).optional(),
    rateLimit: z.number().int().positive().optional(),
    contentType: z.string().max(100).optional(),
    produces: z.array(z.string()).optional(),
    consumes: z.array(z.string()).optional(),
    status: z.enum(['DRAFT', 'DESIGN', 'DEVELOPMENT', 'TESTING', 'COMPLETED', 'DEPRECATED']).optional(),
    implementationStatus: z.enum(['NOT_IMPLEMENTED', 'IMPLEMENTING', 'IMPLEMENTED', 'NEEDS_UPDATE']).optional(),
    testStatus: z.enum(['NOT_TESTED', 'TESTING', 'PASSED', 'FAILED', 'SKIPPED']).optional(),
    relatedTableId: z.string().uuid().optional(),
    autoGenerated: z.boolean().optional(),
    syncedFromModel: z.boolean().optional(),
    createdBy: z.string().max(100).optional(),
    sortOrder: z.number().int().optional(),
    isPublic: z.boolean().optional(),
    parameters: z.array(z.object({
      name: z.string().min(1).max(100),
      displayName: z.string().max(200).optional(),
      type: z.enum(['query', 'path', 'header', 'body', 'formData']),
      dataType: z.enum(['string', 'integer', 'number', 'boolean', 'array', 'object', 'file']),
      format: z.string().max(50).optional(),
      required: z.boolean().optional(),
      defaultValue: z.string().max(500).optional(),
      description: z.string().max(1000).optional(),
      example: z.string().max(1000).optional(),
      enum: z.array(z.string()).optional(),
      minimum: z.number().optional(),
      maximum: z.number().optional(),
      pattern: z.string().max(200).optional(),
      sortOrder: z.number().int().optional(),
      minLength: z.number().int().optional(),
      maxLength: z.number().int().optional(),
      multipleOf: z.number().optional()
    })).optional(),
    responses: z.array(z.object({
      statusCode: z.string().max(10),
      description: z.string().max(1000).optional(),
      contentType: z.string().max(100).optional(),
      schema: z.any().optional(),
      example: z.any().optional(),
      headers: z.record(z.string()).optional(),
      isDefault: z.boolean().optional()
    })).optional()
  })
});

router.post('/endpoints', validateRequest(createEndpointSchema), async (req, res) => {
  try {
    const endpoint = await endpointService.createEndpoint(req.body);
    res.status(201).json({
      success: true,
      data: endpoint,
      message: 'API端点创建成功'
    });
  } catch (error) {
    logger.error('创建API端点失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '创建API端点失败'
    });
  }
});

// 获取API端点列表
const getEndpointsSchema = z.object({
  query: z.object({
    projectId: z.string().uuid(),
    groupId: z.string().uuid().optional(),
    status: z.string().optional(),
    method: z.string().optional(),
    deprecated: z.string().optional().transform(val => val === 'true'),
    search: z.string().optional(),
    page: z.string().optional().transform(val => val ? parseInt(val) : 1),
    pageSize: z.string().optional().transform(val => val ? parseInt(val) : 20)
  })
});

router.get('/endpoints', validateRequest(getEndpointsSchema), async (req, res) => {
  try {
    const { projectId, groupId, status, method, deprecated, search, page, pageSize } = req.query;
    
    const result = await endpointService.getEndpointsByProject(
      projectId as string,
      { 
        groupId: groupId as string, 
        status: status as string, 
        method: method as string, 
        deprecated: deprecated === 'true', 
        search: search as string 
      },
      { 
        page: page ? parseInt(page as string, 10) : undefined, 
        pageSize: pageSize ? parseInt(pageSize as string, 10) : undefined 
      }
    );
    
    res.json({
      success: true,
      data: result.endpoints,
      pagination: {
        page: result.page,
        pageSize: result.pageSize,
        total: result.total,
        totalPages: result.totalPages
      }
    });
  } catch (error) {
    logger.error('获取API端点列表失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取API端点列表失败'
    });
  }
});

// 获取API端点详情
router.get('/endpoints/:id', async (req, res) => {
  try {
    const endpoint = await endpointService.getEndpointById(req.params.id);
    
    if (!endpoint) {
      return res.status(404).json({
        success: false,
        message: 'API端点不存在'
      });
    }
    
    res.json({
      success: true,
      data: endpoint
    });
  } catch (error) {
    logger.error('获取API端点详情失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取API端点详情失败'
    });
  }
});

// 更新API端点
const updateEndpointSchema = z.object({
  body: z.object({
    groupId: z.string().uuid().optional(),
    name: z.string().min(1).max(100).optional(),
    displayName: z.string().max(200).optional(),
    method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS']).optional(),
    path: z.string().min(1).max(500).optional(),
    summary: z.string().max(200).optional(),
    description: z.string().max(2000).optional(),
    tags: z.array(z.string()).optional(),
    deprecated: z.boolean().optional(),
    version: z.string().max(20).optional(),
    authRequired: z.boolean().optional(),
    authType: z.string().max(50).optional(),
    scopes: z.array(z.string()).optional(),
    rateLimit: z.number().int().positive().optional(),
    contentType: z.string().max(100).optional(),
    produces: z.array(z.string()).optional(),
    consumes: z.array(z.string()).optional(),
    status: z.enum(['DRAFT', 'DESIGN', 'DEVELOPMENT', 'TESTING', 'COMPLETED', 'DEPRECATED']).optional(),
    implementationStatus: z.enum(['NOT_IMPLEMENTED', 'IMPLEMENTING', 'IMPLEMENTED', 'NEEDS_UPDATE']).optional(),
    testStatus: z.enum(['NOT_TESTED', 'TESTING', 'PASSED', 'FAILED', 'SKIPPED']).optional(),
    frontendCode: z.string().optional(),
    backendCode: z.string().optional(),
    mockData: z.any().optional(),
    relatedTableId: z.string().uuid().optional(),
    syncedFromModel: z.boolean().optional(),
    lastModifiedBy: z.string().max(100).optional(),
    sortOrder: z.number().int().optional(),
    isPublic: z.boolean().optional(),
    reason: z.string().max(500).optional()
  })
});

router.put('/endpoints/:id', validateRequest(updateEndpointSchema), async (req, res) => {
  try {
    const endpoint = await endpointService.updateEndpoint(req.params.id, req.body);
    res.json({
      success: true,
      data: endpoint,
      message: 'API端点更新成功'
    });
  } catch (error) {
    logger.error('更新API端点失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '更新API端点失败'
    });
  }
});

// 删除API端点
router.delete('/endpoints/:id', async (req, res) => {
  try {
    const deletedBy = req.query.deletedBy as string;
    await endpointService.deleteEndpoint(req.params.id, deletedBy);
    res.json({
      success: true,
      message: 'API端点删除成功'
    });
  } catch (error) {
    logger.error('删除API端点失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '删除API端点失败'
    });
  }
});

// 从数据表生成API端点
const generateFromTableSchema = z.object({
  body: z.object({
    tableId: z.string().uuid(),
    operations: z.array(z.enum(['CREATE', 'READ', 'UPDATE', 'DELETE'])),
    options: z.object({
      groupId: z.string().uuid().optional(),
      pathPrefix: z.string().max(100).optional(),
      authRequired: z.boolean().optional(),
      createdBy: z.string().max(100).optional()
    }).optional()
  })
});

router.post('/endpoints/generate-from-table', validateRequest(generateFromTableSchema), async (req, res) => {
  try {
    const { tableId, operations, options } = req.body;
    const endpoints = await endpointService.generateFromTable(tableId, operations, options);
    
    res.status(201).json({
      success: true,
      data: endpoints,
      message: `成功生成 ${endpoints.length} 个API端点`
    });
  } catch (error) {
    logger.error('从数据表生成API端点失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '从数据表生成API端点失败'
    });
  }
});

// ==================== API分组路由 ====================

// 创建API分组
const createGroupSchema = z.object({
  body: z.object({
    projectId: z.string().uuid(),
    name: z.string().min(1).max(100),
    displayName: z.string().max(200).optional(),
    description: z.string().max(1000).optional(),
    prefix: z.string().max(100).optional(),
    color: z.string().max(20).optional(),
    icon: z.string().max(50).optional(),
    sortOrder: z.number().int().optional(),
    parentId: z.string().uuid().optional(),
    status: z.enum(['ACTIVE', 'INACTIVE']).optional()
  })
});

router.post('/groups', validateRequest(createGroupSchema), async (req, res) => {
  try {
    const group = await groupService.createGroup(req.body);
    res.status(201).json({
      success: true,
      data: group,
      message: 'API分组创建成功'
    });
  } catch (error) {
    logger.error('创建API分组失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '创建API分组失败'
    });
  }
});

// 获取项目的API分组（树形结构）
router.get('/groups', async (req, res) => {
  try {
    const projectId = req.query.projectId as string;
    const flat = req.query.flat === 'true';
    
    if (!projectId) {
      return res.status(400).json({
        success: false,
        message: '项目ID不能为空'
      });
    }
    
    const groups = flat 
      ? await groupService.getFlatGroupsByProject(projectId)
      : await groupService.getGroupsByProject(projectId);
    
    res.json({
      success: true,
      data: groups
    });
  } catch (error) {
    logger.error('获取API分组列表失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取API分组列表失败'
    });
  }
});

// 获取API分组详情
router.get('/groups/:id', async (req, res) => {
  try {
    const group = await groupService.getGroupById(req.params.id);
    
    if (!group) {
      return res.status(404).json({
        success: false,
        message: 'API分组不存在'
      });
    }
    
    res.json({
      success: true,
      data: group
    });
  } catch (error) {
    logger.error('获取API分组详情失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取API分组详情失败'
    });
  }
});

// 更新API分组
const updateGroupSchema = z.object({
  body: z.object({
    name: z.string().min(1).max(100).optional(),
    displayName: z.string().max(200).optional(),
    description: z.string().max(1000).optional(),
    prefix: z.string().max(100).optional(),
    color: z.string().max(20).optional(),
    icon: z.string().max(50).optional(),
    sortOrder: z.number().int().optional(),
    parentId: z.string().uuid().optional(),
    status: z.enum(['ACTIVE', 'INACTIVE']).optional()
  })
});

router.put('/groups/:id', validateRequest(updateGroupSchema), async (req, res) => {
  try {
    const group = await groupService.updateGroup(req.params.id, req.body);
    res.json({
      success: true,
      data: group,
      message: 'API分组更新成功'
    });
  } catch (error) {
    logger.error('更新API分组失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '更新API分组失败'
    });
  }
});

// 删除API分组
router.delete('/groups/:id', async (req, res) => {
  try {
    const moveEndpointsToGroup = req.query.moveEndpointsToGroup as string;
    await groupService.deleteGroup(req.params.id, { moveEndpointsToGroup });
    res.json({
      success: true,
      message: 'API分组删除成功'
    });
  } catch (error) {
    logger.error('删除API分组失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '删除API分组失败'
    });
  }
});

// 移动分组
const moveGroupSchema = z.object({
  body: z.object({
    newParentId: z.string().uuid().optional()
  })
});

router.put('/groups/:id/move', validateRequest(moveGroupSchema), async (req, res) => {
  try {
    const group = await groupService.moveGroup(req.params.id, req.body.newParentId);
    res.json({
      success: true,
      data: group,
      message: 'API分组移动成功'
    });
  } catch (error) {
    logger.error('移动API分组失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '移动API分组失败'
    });
  }
});

// 获取分组统计信息
router.get('/groups/:id/statistics', async (req, res) => {
  try {
    const statistics = await groupService.getGroupStatistics(req.params.id);
    res.json({
      success: true,
      data: statistics
    });
  } catch (error) {
    logger.error('获取分组统计信息失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取分组统计信息失败'
    });
  }
});

// ==================== 同步配置路由 ====================

// 创建同步配置
const createSyncConfigSchema = z.object({
  body: z.object({
    projectId: z.string().uuid(),
    name: z.string().min(1).max(100),
    description: z.string().max(1000).optional(),
    isActive: z.boolean().optional(),
    autoSync: z.boolean().optional(),
    syncDirection: z.enum(['MODEL_TO_API', 'API_TO_MODEL', 'BIDIRECTIONAL']).optional(),
    conflictResolution: z.enum(['MANUAL', 'MODEL_WINS', 'API_WINS', 'MERGE']).optional(),
    tableToEndpointMapping: z.record(z.any()).optional(),
    fieldToParameterMapping: z.record(z.any()).optional(),
    namingConvention: z.enum(['CAMEL_CASE', 'SNAKE_CASE', 'KEBAB_CASE']).optional(),
    includeTables: z.array(z.string()).optional(),
    excludeTables: z.array(z.string()).optional(),
    includeFields: z.array(z.string()).optional(),
    excludeFields: z.array(z.string()).optional(),
    syncInterval: z.number().int().positive().optional()
  })
});

router.post('/sync-configurations', validateRequest(createSyncConfigSchema), async (req, res) => {
  try {
    const config = await syncService.createSyncConfiguration(req.body);
    res.status(201).json({
      success: true,
      data: config,
      message: '同步配置创建成功'
    });
  } catch (error) {
    logger.error('创建同步配置失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '创建同步配置失败'
    });
  }
});

// 获取同步配置列表
router.get('/sync-configurations', async (req, res) => {
  try {
    const projectId = req.query.projectId as string;
    
    if (!projectId) {
      return res.status(400).json({
        success: false,
        message: '项目ID不能为空'
      });
    }
    
    const configs = await syncService.getSyncConfigurations(projectId);
    res.json({
      success: true,
      data: configs
    });
  } catch (error) {
    logger.error('获取同步配置列表失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '获取同步配置列表失败'
    });
  }
});

// 执行同步
const executeSyncSchema = z.object({
  body: z.object({
    dryRun: z.boolean().optional(),
    userId: z.string().max(100).optional()
  })
});

router.post('/sync-configurations/:id/sync', validateRequest(executeSyncSchema), async (req, res) => {
  try {
    const { dryRun, userId } = req.body;
    
    // 获取同步配置
    const configs = await syncService.getSyncConfigurations(req.params.id);
    const config = configs.find(c => c.id === req.params.id);
    
    if (!config) {
      return res.status(404).json({
        success: false,
        message: '同步配置不存在'
      });
    }
    
    let result;
    switch (config.syncDirection) {
      case 'MODEL_TO_API':
        result = await syncService.syncModelToAPI(req.params.id, { dryRun, userId });
        break;
      case 'API_TO_MODEL':
        result = await syncService.syncAPIToModel(req.params.id, { dryRun, userId });
        break;
      case 'BIDIRECTIONAL':
        result = await syncService.syncBidirectional(req.params.id, { dryRun, userId });
        break;
      default:
        return res.status(400).json({
          success: false,
          message: '不支持的同步方向'
        });
    }
    
    res.json({
      success: result.success,
      data: result,
      message: dryRun ? '同步预览完成' : result.message
    });
  } catch (error) {
    logger.error('执行同步失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '执行同步失败'
    });
  }
});

// 检测同步冲突
router.get('/sync-configurations/:id/conflicts', async (req, res) => {
  try {
    const conflicts = await syncService.detectConflicts(req.params.id);
    res.json({
      success: true,
      data: conflicts
    });
  } catch (error) {
    logger.error('检测同步冲突失败', error);
    res.status(400).json({
      success: false,
      message: error.message || '检测同步冲突失败'
    });
  }
});

export default router;