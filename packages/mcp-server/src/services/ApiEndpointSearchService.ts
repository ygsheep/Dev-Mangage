/**
 * API端点搜索服务
 * 提供API端点相关的搜索功能，支持新的APIEndpoint模型
 */
import Fuse from 'fuse.js';
import { SearchService, SearchResult, SearchOptions } from './base/SearchService.js';
import { getPrismaClient } from '../database/index.js';
import { logger, logPerformance } from '../utils/logger.js';
import { DatabaseError } from '../utils/errors.js';
import { config } from '../config/index.js';

/**
 * API端点数据接口
 */
interface ApiEndpointData {
  id: string;
  projectId: string;
  groupId: string | null;
  name: string;
  displayName: string | null;
  method: string;
  path: string;
  summary: string | null;
  description: string | null;
  tags: string | null; // JSON array
  deprecated: boolean;
  version: string;
  status: string;
  implementationStatus: string;
  testStatus: string;
  authRequired: boolean;
  authType: string | null;
  contentType: string | null;
  relatedTableId: string | null;
  autoGenerated: boolean;
  syncedFromModel: boolean;
  lastSyncAt: Date | null;
  sortOrder: number;
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;
  // 关联数据
  project: {
    name: string;
    status: string;
  };
  group: {
    name: string;
    displayName: string | null;
  } | null;
  relatedTable: {
    name: string;
    displayName: string | null;
  } | null;
  // 统计信息
  _count: {
    parameters: number;
    responses: number;
    examples: number;
    testCases: number;
    documentation: number;
  };
}

/**
 * API端点搜索选项接口
 */
interface ApiEndpointSearchOptions extends SearchOptions {
  /** 项目ID过滤 */
  projectId?: string;
  /** 分组ID过滤 */
  groupId?: string;
  /** HTTP方法过滤 */
  methods?: string[];
  /** 状态过滤 */
  statuses?: string[];
  /** 实现状态过滤 */
  implementationStatuses?: string[];
  /** 测试状态过滤 */
  testStatuses?: string[];
  /** 是否包含已弃用的端点 */
  includeDeprecated?: boolean;
  /** 是否只显示公共端点 */
  publicOnly?: boolean;
  /** 认证类型过滤 */
  authTypes?: string[];
  /** 标签过滤 */
  tags?: string[];
  /** 是否包含自动生成的端点 */
  includeAutoGenerated?: boolean;
  /** 同步状态过滤 */
  syncStatus?: 'synced' | 'not_synced' | 'all';
  /** 版本过滤 */
  versions?: string[];
}

/**
 * API端点搜索服务类
 */
export class ApiEndpointSearchService extends SearchService<ApiEndpointData> {
  private fuseIndex: Fuse<ApiEndpointData> | null = null;
  private endpointsCache: ApiEndpointData[] = [];

  constructor() {
    super('ApiEndpointSearchService');
  }

  /**
   * 初始化服务
   */
  public async initialize(): Promise<void> {
    logger.info('🔍 初始化API端点搜索服务...');
    
    try {
      await this.buildIndex();
      logger.info('✅ API端点搜索服务初始化完成');
    } catch (error) {
      logger.error('❌ API端点搜索服务初始化失败:', error);
      throw error;
    }
  }

  /**
   * 构建搜索索引
   */
  public async buildIndex(): Promise<void> {
    const cacheKey = 'api-endpoints-index';
    
    // 检查缓存
    if (!this.needsIndexUpdate()) {
      const cachedIndex = this.getCache(cacheKey);
      if (cachedIndex) {
        this.fuseIndex = cachedIndex.fuseIndex;
        this.endpointsCache = cachedIndex.endpoints;
        logger.debug('使用缓存的API端点搜索索引');
        return;
      }
    }

    try {
      const prisma = getPrismaClient();
      
      // 获取API端点数据
      const endpoints = await prisma.aPIEndpoint.findMany({
        select: {
          id: true,
          projectId: true,
          groupId: true,
          name: true,
          displayName: true,
          method: true,
          path: true,
          summary: true,
          description: true,
          tags: true,
          deprecated: true,
          version: true,
          status: true,
          implementationStatus: true,
          testStatus: true,
          authRequired: true,
          authType: true,
          contentType: true,
          relatedTableId: true,
          autoGenerated: true,
          syncedFromModel: true,
          lastSyncAt: true,
          sortOrder: true,
          isPublic: true,
          createdAt: true,
          updatedAt: true,
          project: {
            select: {
              name: true,
              status: true
            }
          },
          group: {
            select: {
              name: true,
              displayName: true
            }
          },
          relatedTable: {
            select: {
              name: true,
              displayName: true
            }
          },
          _count: {
            select: {
              parameters: true,
              responses: true,
              examples: true,
              testCases: true,
              documentation: true
            }
          }
        },
        orderBy: [
          { sortOrder: 'asc' },
          { updatedAt: 'desc' }
        ]
      });

      // 构建Fuse索引
      this.fuseIndex = new Fuse(endpoints, {
        keys: [
          { name: 'name', weight: 0.3 },
          { name: 'displayName', weight: 0.25 },
          { name: 'path', weight: 0.2 },
          { name: 'summary', weight: 0.15 },
          { name: 'description', weight: 0.1 },
          { name: 'method', weight: 0.08 },
          { name: 'project.name', weight: 0.05 },
          { name: 'group.name', weight: 0.03 },
          { name: 'group.displayName', weight: 0.02 },
          { name: 'relatedTable.name', weight: 0.02 }
        ],
        threshold: config.search.fuseThreshold,
        includeScore: true,
        includeMatches: true,
        minMatchCharLength: 1,
        distance: 100,
        location: 0,
        ignoreLocation: false,
        ignoreFieldNorm: false
      });

      this.endpointsCache = endpoints;
      
      // 缓存索引
      this.setCache(cacheKey, {
        fuseIndex: this.fuseIndex,
        endpoints: this.endpointsCache
      });
      
      this.updateIndexTimestamp();
      logger.info(`✅ API端点搜索索引构建完成，包含 ${endpoints.length} 个端点`);
      
    } catch (error) {
      throw new DatabaseError('构建API端点搜索索引失败', {
        originalError: error
      });
    }
  }

  /**
   * 搜索API端点
   */
  public async search(
    query: string, 
    options: ApiEndpointSearchOptions = {}
  ): Promise<SearchResult<ApiEndpointData>[]> {
    return this.executeSearch(async () => {
      this.validateQuery(query);
      const validatedOptions = this.validateOptions(options);

      // 确保索引存在
      if (!this.fuseIndex) {
        await this.buildIndex();
      }

      if (!this.fuseIndex) {
        throw new DatabaseError('API端点搜索索引未构建');
      }

      // 执行搜索
      const searchResults = this.fuseIndex.search(query, {
        limit: validatedOptions.limit! * 3 // 获取更多结果用于后续过滤
      });

      // 转换结果格式
      let results: SearchResult<ApiEndpointData>[] = searchResults.map(result => ({
        item: result.item,
        score: 1 - (result.score || 0), // Fuse.js的score是距离，需要转换为相似度
        matches: result.matches?.map(match => match.key || '') || [],
        highlights: this.extractHighlights(result.matches || [])
      }));

      // 应用过滤条件
      results = this.applyFilters(results, options);

      // 格式化并返回结果
      return this.formatResults(results, validatedOptions);
    }, 'search');
  }

  /**
   * 获取搜索建议
   */
  public async getSuggestions(query: string, limit: number = 5): Promise<string[]> {
    return this.executeSearch(async () => {
      this.validateQuery(query);

      if (!this.fuseIndex) {
        await this.buildIndex();
      }

      const results = this.fuseIndex!.search(query, { limit: limit * 3 });
      const suggestions = new Set<string>();
      
      results.forEach(result => {
        const endpoint = result.item;
        
        // 添加端点名称
        if (endpoint.name.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.name);
        }
        
        // 添加路径
        if (endpoint.path.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.path);
        }
        
        // 添加HTTP方法
        if (endpoint.method.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.method);
        }
        
        // 添加显示名称
        if (endpoint.displayName && endpoint.displayName.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.displayName);
        }
      });

      return Array.from(suggestions).slice(0, limit);
    }, 'getSuggestions');
  }

  /**
   * 根据项目ID获取端点
   */
  public async getEndpointsByProject(
    projectId: string, 
    options: Partial<ApiEndpointSearchOptions> = {}
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      let endpoints = this.endpointsCache.filter(e => e.projectId === projectId);
      
      // 应用过滤条件
      const results = this.applyFilters(
        endpoints.map(item => ({ item, score: 1, matches: [] })), 
        options
      );
      
      return results
        .map(r => r.item)
        .slice(0, options.limit || config.search.defaultLimit);
    }, 'getEndpointsByProject');
  }

  /**
   * 根据分组ID获取端点
   */
  public async getEndpointsByGroup(
    groupId: string,
    options: Partial<ApiEndpointSearchOptions> = {}
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      let endpoints = this.endpointsCache.filter(e => e.groupId === groupId);
      
      const results = this.applyFilters(
        endpoints.map(item => ({ item, score: 1, matches: [] })), 
        options
      );
      
      return results
        .map(r => r.item)
        .slice(0, options.limit || config.search.defaultLimit);
    }, 'getEndpointsByGroup');
  }

  /**
   * 获取相关的端点推荐
   */
  public async getRelatedEndpoints(
    endpointId: string, 
    limit: number = 5
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      const targetEndpoint = this.endpointsCache.find(e => e.id === endpointId);
      if (!targetEndpoint) {
        return [];
      }

      // 基于相似性的推荐算法
      const related = this.endpointsCache
        .filter(e => e.id !== endpointId)
        .map(endpoint => {
          let similarity = 0;
          
          // 同项目加分
          if (endpoint.projectId === targetEndpoint.projectId) {
            similarity += 0.3;
          }
          
          // 同分组加分
          if (endpoint.groupId && endpoint.groupId === targetEndpoint.groupId) {
            similarity += 0.2;
          }
          
          // 相同HTTP方法加分
          if (endpoint.method === targetEndpoint.method) {
            similarity += 0.15;
          }
          
          // 路径相似性
          const pathSimilarity = this.calculatePathSimilarity(endpoint.path, targetEndpoint.path);
          similarity += pathSimilarity * 0.2;
          
          // 名称相似性
          const nameSimilarity = this.calculateNameSimilarity(endpoint.name, targetEndpoint.name);
          similarity += nameSimilarity * 0.15;
          
          return { endpoint, similarity };
        })
        .filter(item => item.similarity > 0.1)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, limit)
        .map(item => item.endpoint);

      return related;
    }, 'getRelatedEndpoints');
  }

  /**
   * 获取API端点统计信息
   */
  public async getEndpointStats(): Promise<{
    total: number;
    byMethod: Record<string, number>;
    byStatus: Record<string, number>;
    byImplementationStatus: Record<string, number>;
    byTestStatus: Record<string, number>;
    deprecated: number;
    authRequired: number;
    autoGenerated: number;
    synced: number;
  }> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      const stats = {
        total: this.endpointsCache.length,
        byMethod: {} as Record<string, number>,
        byStatus: {} as Record<string, number>,
        byImplementationStatus: {} as Record<string, number>,
        byTestStatus: {} as Record<string, number>,
        deprecated: 0,
        authRequired: 0,
        autoGenerated: 0,
        synced: 0
      };

      this.endpointsCache.forEach(endpoint => {
        // 统计HTTP方法分布
        stats.byMethod[endpoint.method] = (stats.byMethod[endpoint.method] || 0) + 1;
        
        // 统计状态分布
        stats.byStatus[endpoint.status] = (stats.byStatus[endpoint.status] || 0) + 1;
        
        // 统计实现状态分布
        stats.byImplementationStatus[endpoint.implementationStatus] = 
          (stats.byImplementationStatus[endpoint.implementationStatus] || 0) + 1;
        
        // 统计测试状态分布
        stats.byTestStatus[endpoint.testStatus] = 
          (stats.byTestStatus[endpoint.testStatus] || 0) + 1;
        
        // 统计特殊标记
        if (endpoint.deprecated) stats.deprecated++;
        if (endpoint.authRequired) stats.authRequired++;
        if (endpoint.autoGenerated) stats.autoGenerated++;
        if (endpoint.syncedFromModel) stats.synced++;
      });

      return stats;
    }, 'getEndpointStats');
  }

  /**
   * 应用过滤条件
   */
  private applyFilters(
    results: SearchResult<ApiEndpointData>[], 
    options: ApiEndpointSearchOptions
  ): SearchResult<ApiEndpointData>[] {
    let filtered = results;

    // 项目过滤
    if (options.projectId) {
      filtered = filtered.filter(result => 
        result.item.projectId === options.projectId
      );
    }

    // 分组过滤
    if (options.groupId) {
      filtered = filtered.filter(result => 
        result.item.groupId === options.groupId
      );
    }

    // HTTP方法过滤
    if (options.methods && options.methods.length > 0) {
      filtered = filtered.filter(result => 
        options.methods!.includes(result.item.method)
      );
    }

    // 状态过滤
    if (options.statuses && options.statuses.length > 0) {
      filtered = filtered.filter(result => 
        options.statuses!.includes(result.item.status)
      );
    }

    // 实现状态过滤
    if (options.implementationStatuses && options.implementationStatuses.length > 0) {
      filtered = filtered.filter(result => 
        options.implementationStatuses!.includes(result.item.implementationStatus)
      );
    }

    // 测试状态过滤
    if (options.testStatuses && options.testStatuses.length > 0) {
      filtered = filtered.filter(result => 
        options.testStatuses!.includes(result.item.testStatus)
      );
    }

    // 已弃用过滤
    if (!options.includeDeprecated) {
      filtered = filtered.filter(result => !result.item.deprecated);
    }

    // 公共端点过滤
    if (options.publicOnly) {
      filtered = filtered.filter(result => result.item.isPublic);
    }

    // 认证类型过滤
    if (options.authTypes && options.authTypes.length > 0) {
      filtered = filtered.filter(result => 
        result.item.authType && options.authTypes!.includes(result.item.authType)
      );
    }

    // 标签过滤
    if (options.tags && options.tags.length > 0) {
      filtered = filtered.filter(result => {
        if (!result.item.tags) return false;
        try {
          const endpointTags = JSON.parse(result.item.tags);
          return Array.isArray(endpointTags) && 
                 options.tags!.some(tag => endpointTags.includes(tag));
        } catch {
          return false;
        }
      });
    }

    // 自动生成过滤
    if (!options.includeAutoGenerated) {
      filtered = filtered.filter(result => !result.item.autoGenerated);
    }

    // 同步状态过滤
    if (options.syncStatus && options.syncStatus !== 'all') {
      filtered = filtered.filter(result => {
        const isSynced = result.item.syncedFromModel && result.item.lastSyncAt;
        return options.syncStatus === 'synced' ? isSynced : !isSynced;
      });
    }

    // 版本过滤
    if (options.versions && options.versions.length > 0) {
      filtered = filtered.filter(result => 
        options.versions!.includes(result.item.version)
      );
    }

    return filtered;
  }

  /**
   * 提取高亮信息
   */
  private extractHighlights(matches: readonly any[]): Record<string, string[]> {
    const highlights: Record<string, string[]> = {};
    
    Array.from(matches).forEach(match => {
      if (match.key && match.indices) {
        highlights[match.key] = match.indices.map((indices: number[]) => {
          const [start, end] = indices;
          return match.value.substring(start, end + 1);
        });
      }
    });

    return highlights;
  }

  /**
   * 计算路径相似性
   */
  private calculatePathSimilarity(path1: string, path2: string): number {
    const segments1 = path1.split('/').filter(s => s.length > 0);
    const segments2 = path2.split('/').filter(s => s.length > 0);
    
    let commonSegments = 0;
    const maxSegments = Math.max(segments1.length, segments2.length);
    
    for (let i = 0; i < Math.min(segments1.length, segments2.length); i++) {
      if (segments1[i] === segments2[i] || 
          (segments1[i].startsWith(':') && segments2[i].startsWith(':')) ||
          (segments1[i].startsWith('{') && segments2[i].startsWith('{'))) {
        commonSegments++;
      }
    }
    
    return maxSegments > 0 ? commonSegments / maxSegments : 0;
  }

  /**
   * 计算名称相似性
   */
  private calculateNameSimilarity(name1: string, name2: string): number {
    const words1 = name1.toLowerCase().split(/\W+/).filter(w => w.length > 0);
    const words2 = name2.toLowerCase().split(/\W+/).filter(w => w.length > 0);
    
    let commonWords = 0;
    const allWords = new Set([...words1, ...words2]);
    
    allWords.forEach(word => {
      if (words1.includes(word) && words2.includes(word)) {
        commonWords++;
      }
    });
    
    return allWords.size > 0 ? commonWords / allWords.size : 0;
  }
}

/**
 * 导出API端点搜索服务单例
 */
export const apiEndpointSearchService = new ApiEndpointSearchService();