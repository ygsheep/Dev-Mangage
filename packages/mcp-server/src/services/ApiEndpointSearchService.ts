/**
 * APIç«¯ç‚¹æœç´¢æœåŠ¡
 * æä¾›APIç«¯ç‚¹ç›¸å…³çš„æœç´¢åŠŸèƒ½ï¼Œæ”¯æŒæ–°çš„APIEndpointæ¨¡å‹
 */
import Fuse from 'fuse.js';
import { SearchService, SearchResult, SearchOptions } from './base/SearchService.js';
import { getPrismaClient } from '../database/index.js';
import { logger, logPerformance } from '../utils/logger.js';
import { DatabaseError } from '../utils/errors.js';
import { config } from '../config/index.js';

/**
 * APIç«¯ç‚¹æ•°æ®æ¥å£
 */
interface ApiEndpointData {
  id: string;
  projectId: string;
  groupId: string | null;
  name: string;
  displayName: string | null;
  method: string;
  path: string;
  summary: string | null;
  description: string | null;
  tags: string | null; // JSON array
  deprecated: boolean;
  version: string;
  status: string;
  implementationStatus: string;
  testStatus: string;
  authRequired: boolean;
  authType: string | null;
  contentType: string | null;
  relatedTableId: string | null;
  autoGenerated: boolean;
  syncedFromModel: boolean;
  lastSyncAt: Date | null;
  sortOrder: number;
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;
  // å…³è”æ•°æ®
  project: {
    name: string;
    status: string;
  };
  group: {
    name: string;
    displayName: string | null;
  } | null;
  relatedTable: {
    name: string;
    displayName: string | null;
  } | null;
  // ç»Ÿè®¡ä¿¡æ¯
  _count: {
    parameters: number;
    responses: number;
    examples: number;
    testCases: number;
    documentation: number;
  };
}

/**
 * APIç«¯ç‚¹æœç´¢é€‰é¡¹æ¥å£
 */
interface ApiEndpointSearchOptions extends SearchOptions {
  /** é¡¹ç›®IDè¿‡æ»¤ */
  projectId?: string;
  /** åˆ†ç»„IDè¿‡æ»¤ */
  groupId?: string;
  /** HTTPæ–¹æ³•è¿‡æ»¤ */
  methods?: string[];
  /** çŠ¶æ€è¿‡æ»¤ */
  statuses?: string[];
  /** å®ç°çŠ¶æ€è¿‡æ»¤ */
  implementationStatuses?: string[];
  /** æµ‹è¯•çŠ¶æ€è¿‡æ»¤ */
  testStatuses?: string[];
  /** æ˜¯å¦åŒ…å«å·²å¼ƒç”¨çš„ç«¯ç‚¹ */
  includeDeprecated?: boolean;
  /** æ˜¯å¦åªæ˜¾ç¤ºå…¬å…±ç«¯ç‚¹ */
  publicOnly?: boolean;
  /** è®¤è¯ç±»å‹è¿‡æ»¤ */
  authTypes?: string[];
  /** æ ‡ç­¾è¿‡æ»¤ */
  tags?: string[];
  /** æ˜¯å¦åŒ…å«è‡ªåŠ¨ç”Ÿæˆçš„ç«¯ç‚¹ */
  includeAutoGenerated?: boolean;
  /** åŒæ­¥çŠ¶æ€è¿‡æ»¤ */
  syncStatus?: 'synced' | 'not_synced' | 'all';
  /** ç‰ˆæœ¬è¿‡æ»¤ */
  versions?: string[];
}

/**
 * APIç«¯ç‚¹æœç´¢æœåŠ¡ç±»
 */
export class ApiEndpointSearchService extends SearchService<ApiEndpointData> {
  private fuseIndex: Fuse<ApiEndpointData> | null = null;
  private endpointsCache: ApiEndpointData[] = [];

  constructor() {
    super('ApiEndpointSearchService');
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡
   */
  public async initialize(): Promise<void> {
    logger.info('ğŸ” åˆå§‹åŒ–APIç«¯ç‚¹æœç´¢æœåŠ¡...');
    
    try {
      await this.buildIndex();
      logger.info('âœ… APIç«¯ç‚¹æœç´¢æœåŠ¡åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      logger.error('âŒ APIç«¯ç‚¹æœç´¢æœåŠ¡åˆå§‹åŒ–å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æ„å»ºæœç´¢ç´¢å¼•
   */
  public async buildIndex(): Promise<void> {
    const cacheKey = 'api-endpoints-index';
    
    // æ£€æŸ¥ç¼“å­˜
    if (!this.needsIndexUpdate()) {
      const cachedIndex = this.getCache(cacheKey);
      if (cachedIndex) {
        this.fuseIndex = cachedIndex.fuseIndex;
        this.endpointsCache = cachedIndex.endpoints;
        logger.debug('ä½¿ç”¨ç¼“å­˜çš„APIç«¯ç‚¹æœç´¢ç´¢å¼•');
        return;
      }
    }

    try {
      const prisma = getPrismaClient();
      
      // è·å–APIç«¯ç‚¹æ•°æ®
      const endpoints = await prisma.aPIEndpoint.findMany({
        select: {
          id: true,
          projectId: true,
          groupId: true,
          name: true,
          displayName: true,
          method: true,
          path: true,
          summary: true,
          description: true,
          tags: true,
          deprecated: true,
          version: true,
          status: true,
          implementationStatus: true,
          testStatus: true,
          authRequired: true,
          authType: true,
          contentType: true,
          relatedTableId: true,
          autoGenerated: true,
          syncedFromModel: true,
          lastSyncAt: true,
          sortOrder: true,
          isPublic: true,
          createdAt: true,
          updatedAt: true,
          project: {
            select: {
              name: true,
              status: true
            }
          },
          group: {
            select: {
              name: true,
              displayName: true
            }
          },
          relatedTable: {
            select: {
              name: true,
              displayName: true
            }
          },
          _count: {
            select: {
              parameters: true,
              responses: true,
              examples: true,
              testCases: true,
              documentation: true
            }
          }
        },
        orderBy: [
          { sortOrder: 'asc' },
          { updatedAt: 'desc' }
        ]
      });

      // æ„å»ºFuseç´¢å¼•
      this.fuseIndex = new Fuse(endpoints, {
        keys: [
          { name: 'name', weight: 0.3 },
          { name: 'displayName', weight: 0.25 },
          { name: 'path', weight: 0.2 },
          { name: 'summary', weight: 0.15 },
          { name: 'description', weight: 0.1 },
          { name: 'method', weight: 0.08 },
          { name: 'project.name', weight: 0.05 },
          { name: 'group.name', weight: 0.03 },
          { name: 'group.displayName', weight: 0.02 },
          { name: 'relatedTable.name', weight: 0.02 }
        ],
        threshold: config.search.fuseThreshold,
        includeScore: true,
        includeMatches: true,
        minMatchCharLength: 1,
        distance: 100,
        location: 0,
        ignoreLocation: false,
        ignoreFieldNorm: false
      });

      this.endpointsCache = endpoints;
      
      // ç¼“å­˜ç´¢å¼•
      this.setCache(cacheKey, {
        fuseIndex: this.fuseIndex,
        endpoints: this.endpointsCache
      });
      
      this.updateIndexTimestamp();
      logger.info(`âœ… APIç«¯ç‚¹æœç´¢ç´¢å¼•æ„å»ºå®Œæˆï¼ŒåŒ…å« ${endpoints.length} ä¸ªç«¯ç‚¹`);
      
    } catch (error) {
      throw new DatabaseError('æ„å»ºAPIç«¯ç‚¹æœç´¢ç´¢å¼•å¤±è´¥', {
        originalError: error
      });
    }
  }

  /**
   * æœç´¢APIç«¯ç‚¹
   */
  public async search(
    query: string, 
    options: ApiEndpointSearchOptions = {}
  ): Promise<SearchResult<ApiEndpointData>[]> {
    return this.executeSearch(async () => {
      this.validateQuery(query);
      const validatedOptions = this.validateOptions(options);

      // ç¡®ä¿ç´¢å¼•å­˜åœ¨
      if (!this.fuseIndex) {
        await this.buildIndex();
      }

      if (!this.fuseIndex) {
        throw new DatabaseError('APIç«¯ç‚¹æœç´¢ç´¢å¼•æœªæ„å»º');
      }

      // æ‰§è¡Œæœç´¢
      const searchResults = this.fuseIndex.search(query, {
        limit: validatedOptions.limit! * 3 // è·å–æ›´å¤šç»“æœç”¨äºåç»­è¿‡æ»¤
      });

      // è½¬æ¢ç»“æœæ ¼å¼
      let results: SearchResult<ApiEndpointData>[] = searchResults.map(result => ({
        item: result.item,
        score: 1 - (result.score || 0), // Fuse.jsçš„scoreæ˜¯è·ç¦»ï¼Œéœ€è¦è½¬æ¢ä¸ºç›¸ä¼¼åº¦
        matches: result.matches?.map(match => match.key || '') || [],
        highlights: this.extractHighlights(result.matches || [])
      }));

      // åº”ç”¨è¿‡æ»¤æ¡ä»¶
      results = this.applyFilters(results, options);

      // æ ¼å¼åŒ–å¹¶è¿”å›ç»“æœ
      return this.formatResults(results, validatedOptions);
    }, 'search');
  }

  /**
   * è·å–æœç´¢å»ºè®®
   */
  public async getSuggestions(query: string, limit: number = 5): Promise<string[]> {
    return this.executeSearch(async () => {
      this.validateQuery(query);

      if (!this.fuseIndex) {
        await this.buildIndex();
      }

      const results = this.fuseIndex!.search(query, { limit: limit * 3 });
      const suggestions = new Set<string>();
      
      results.forEach(result => {
        const endpoint = result.item;
        
        // æ·»åŠ ç«¯ç‚¹åç§°
        if (endpoint.name.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.name);
        }
        
        // æ·»åŠ è·¯å¾„
        if (endpoint.path.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.path);
        }
        
        // æ·»åŠ HTTPæ–¹æ³•
        if (endpoint.method.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.method);
        }
        
        // æ·»åŠ æ˜¾ç¤ºåç§°
        if (endpoint.displayName && endpoint.displayName.toLowerCase().includes(query.toLowerCase())) {
          suggestions.add(endpoint.displayName);
        }
      });

      return Array.from(suggestions).slice(0, limit);
    }, 'getSuggestions');
  }

  /**
   * æ ¹æ®é¡¹ç›®IDè·å–ç«¯ç‚¹
   */
  public async getEndpointsByProject(
    projectId: string, 
    options: Partial<ApiEndpointSearchOptions> = {}
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      let endpoints = this.endpointsCache.filter(e => e.projectId === projectId);
      
      // åº”ç”¨è¿‡æ»¤æ¡ä»¶
      const results = this.applyFilters(
        endpoints.map(item => ({ item, score: 1, matches: [] })), 
        options
      );
      
      return results
        .map(r => r.item)
        .slice(0, options.limit || config.search.defaultLimit);
    }, 'getEndpointsByProject');
  }

  /**
   * æ ¹æ®åˆ†ç»„IDè·å–ç«¯ç‚¹
   */
  public async getEndpointsByGroup(
    groupId: string,
    options: Partial<ApiEndpointSearchOptions> = {}
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      let endpoints = this.endpointsCache.filter(e => e.groupId === groupId);
      
      const results = this.applyFilters(
        endpoints.map(item => ({ item, score: 1, matches: [] })), 
        options
      );
      
      return results
        .map(r => r.item)
        .slice(0, options.limit || config.search.defaultLimit);
    }, 'getEndpointsByGroup');
  }

  /**
   * è·å–ç›¸å…³çš„ç«¯ç‚¹æ¨è
   */
  public async getRelatedEndpoints(
    endpointId: string, 
    limit: number = 5
  ): Promise<ApiEndpointData[]> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      const targetEndpoint = this.endpointsCache.find(e => e.id === endpointId);
      if (!targetEndpoint) {
        return [];
      }

      // åŸºäºç›¸ä¼¼æ€§çš„æ¨èç®—æ³•
      const related = this.endpointsCache
        .filter(e => e.id !== endpointId)
        .map(endpoint => {
          let similarity = 0;
          
          // åŒé¡¹ç›®åŠ åˆ†
          if (endpoint.projectId === targetEndpoint.projectId) {
            similarity += 0.3;
          }
          
          // åŒåˆ†ç»„åŠ åˆ†
          if (endpoint.groupId && endpoint.groupId === targetEndpoint.groupId) {
            similarity += 0.2;
          }
          
          // ç›¸åŒHTTPæ–¹æ³•åŠ åˆ†
          if (endpoint.method === targetEndpoint.method) {
            similarity += 0.15;
          }
          
          // è·¯å¾„ç›¸ä¼¼æ€§
          const pathSimilarity = this.calculatePathSimilarity(endpoint.path, targetEndpoint.path);
          similarity += pathSimilarity * 0.2;
          
          // åç§°ç›¸ä¼¼æ€§
          const nameSimilarity = this.calculateNameSimilarity(endpoint.name, targetEndpoint.name);
          similarity += nameSimilarity * 0.15;
          
          return { endpoint, similarity };
        })
        .filter(item => item.similarity > 0.1)
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, limit)
        .map(item => item.endpoint);

      return related;
    }, 'getRelatedEndpoints');
  }

  /**
   * è·å–APIç«¯ç‚¹ç»Ÿè®¡ä¿¡æ¯
   */
  public async getEndpointStats(): Promise<{
    total: number;
    byMethod: Record<string, number>;
    byStatus: Record<string, number>;
    byImplementationStatus: Record<string, number>;
    byTestStatus: Record<string, number>;
    deprecated: number;
    authRequired: number;
    autoGenerated: number;
    synced: number;
  }> {
    return this.executeSearch(async () => {
      if (this.endpointsCache.length === 0) {
        await this.buildIndex();
      }

      const stats = {
        total: this.endpointsCache.length,
        byMethod: {} as Record<string, number>,
        byStatus: {} as Record<string, number>,
        byImplementationStatus: {} as Record<string, number>,
        byTestStatus: {} as Record<string, number>,
        deprecated: 0,
        authRequired: 0,
        autoGenerated: 0,
        synced: 0
      };

      this.endpointsCache.forEach(endpoint => {
        // ç»Ÿè®¡HTTPæ–¹æ³•åˆ†å¸ƒ
        stats.byMethod[endpoint.method] = (stats.byMethod[endpoint.method] || 0) + 1;
        
        // ç»Ÿè®¡çŠ¶æ€åˆ†å¸ƒ
        stats.byStatus[endpoint.status] = (stats.byStatus[endpoint.status] || 0) + 1;
        
        // ç»Ÿè®¡å®ç°çŠ¶æ€åˆ†å¸ƒ
        stats.byImplementationStatus[endpoint.implementationStatus] = 
          (stats.byImplementationStatus[endpoint.implementationStatus] || 0) + 1;
        
        // ç»Ÿè®¡æµ‹è¯•çŠ¶æ€åˆ†å¸ƒ
        stats.byTestStatus[endpoint.testStatus] = 
          (stats.byTestStatus[endpoint.testStatus] || 0) + 1;
        
        // ç»Ÿè®¡ç‰¹æ®Šæ ‡è®°
        if (endpoint.deprecated) stats.deprecated++;
        if (endpoint.authRequired) stats.authRequired++;
        if (endpoint.autoGenerated) stats.autoGenerated++;
        if (endpoint.syncedFromModel) stats.synced++;
      });

      return stats;
    }, 'getEndpointStats');
  }

  /**
   * åº”ç”¨è¿‡æ»¤æ¡ä»¶
   */
  private applyFilters(
    results: SearchResult<ApiEndpointData>[], 
    options: ApiEndpointSearchOptions
  ): SearchResult<ApiEndpointData>[] {
    let filtered = results;

    // é¡¹ç›®è¿‡æ»¤
    if (options.projectId) {
      filtered = filtered.filter(result => 
        result.item.projectId === options.projectId
      );
    }

    // åˆ†ç»„è¿‡æ»¤
    if (options.groupId) {
      filtered = filtered.filter(result => 
        result.item.groupId === options.groupId
      );
    }

    // HTTPæ–¹æ³•è¿‡æ»¤
    if (options.methods && options.methods.length > 0) {
      filtered = filtered.filter(result => 
        options.methods!.includes(result.item.method)
      );
    }

    // çŠ¶æ€è¿‡æ»¤
    if (options.statuses && options.statuses.length > 0) {
      filtered = filtered.filter(result => 
        options.statuses!.includes(result.item.status)
      );
    }

    // å®ç°çŠ¶æ€è¿‡æ»¤
    if (options.implementationStatuses && options.implementationStatuses.length > 0) {
      filtered = filtered.filter(result => 
        options.implementationStatuses!.includes(result.item.implementationStatus)
      );
    }

    // æµ‹è¯•çŠ¶æ€è¿‡æ»¤
    if (options.testStatuses && options.testStatuses.length > 0) {
      filtered = filtered.filter(result => 
        options.testStatuses!.includes(result.item.testStatus)
      );
    }

    // å·²å¼ƒç”¨è¿‡æ»¤
    if (!options.includeDeprecated) {
      filtered = filtered.filter(result => !result.item.deprecated);
    }

    // å…¬å…±ç«¯ç‚¹è¿‡æ»¤
    if (options.publicOnly) {
      filtered = filtered.filter(result => result.item.isPublic);
    }

    // è®¤è¯ç±»å‹è¿‡æ»¤
    if (options.authTypes && options.authTypes.length > 0) {
      filtered = filtered.filter(result => 
        result.item.authType && options.authTypes!.includes(result.item.authType)
      );
    }

    // æ ‡ç­¾è¿‡æ»¤
    if (options.tags && options.tags.length > 0) {
      filtered = filtered.filter(result => {
        if (!result.item.tags) return false;
        try {
          const endpointTags = JSON.parse(result.item.tags);
          return Array.isArray(endpointTags) && 
                 options.tags!.some(tag => endpointTags.includes(tag));
        } catch {
          return false;
        }
      });
    }

    // è‡ªåŠ¨ç”Ÿæˆè¿‡æ»¤
    if (!options.includeAutoGenerated) {
      filtered = filtered.filter(result => !result.item.autoGenerated);
    }

    // åŒæ­¥çŠ¶æ€è¿‡æ»¤
    if (options.syncStatus && options.syncStatus !== 'all') {
      filtered = filtered.filter(result => {
        const isSynced = result.item.syncedFromModel && result.item.lastSyncAt;
        return options.syncStatus === 'synced' ? isSynced : !isSynced;
      });
    }

    // ç‰ˆæœ¬è¿‡æ»¤
    if (options.versions && options.versions.length > 0) {
      filtered = filtered.filter(result => 
        options.versions!.includes(result.item.version)
      );
    }

    return filtered;
  }

  /**
   * æå–é«˜äº®ä¿¡æ¯
   */
  private extractHighlights(matches: readonly any[]): Record<string, string[]> {
    const highlights: Record<string, string[]> = {};
    
    Array.from(matches).forEach(match => {
      if (match.key && match.indices) {
        highlights[match.key] = match.indices.map((indices: number[]) => {
          const [start, end] = indices;
          return match.value.substring(start, end + 1);
        });
      }
    });

    return highlights;
  }

  /**
   * è®¡ç®—è·¯å¾„ç›¸ä¼¼æ€§
   */
  private calculatePathSimilarity(path1: string, path2: string): number {
    const segments1 = path1.split('/').filter(s => s.length > 0);
    const segments2 = path2.split('/').filter(s => s.length > 0);
    
    let commonSegments = 0;
    const maxSegments = Math.max(segments1.length, segments2.length);
    
    for (let i = 0; i < Math.min(segments1.length, segments2.length); i++) {
      if (segments1[i] === segments2[i] || 
          (segments1[i].startsWith(':') && segments2[i].startsWith(':')) ||
          (segments1[i].startsWith('{') && segments2[i].startsWith('{'))) {
        commonSegments++;
      }
    }
    
    return maxSegments > 0 ? commonSegments / maxSegments : 0;
  }

  /**
   * è®¡ç®—åç§°ç›¸ä¼¼æ€§
   */
  private calculateNameSimilarity(name1: string, name2: string): number {
    const words1 = name1.toLowerCase().split(/\W+/).filter(w => w.length > 0);
    const words2 = name2.toLowerCase().split(/\W+/).filter(w => w.length > 0);
    
    let commonWords = 0;
    const allWords = new Set([...words1, ...words2]);
    
    allWords.forEach(word => {
      if (words1.includes(word) && words2.includes(word)) {
        commonWords++;
      }
    });
    
    return allWords.size > 0 ? commonWords / allWords.size : 0;
  }
}

/**
 * å¯¼å‡ºAPIç«¯ç‚¹æœç´¢æœåŠ¡å•ä¾‹
 */
export const apiEndpointSearchService = new ApiEndpointSearchService();