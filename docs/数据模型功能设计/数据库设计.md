# DevAPI Manager 数据库设计文档

## 1. 概述

### 1.1 设计目标
本文档定义了DevAPI Manager数据模型管理功能的完整数据库架构设计，旨在支持：
- 灵活的数据表结构管理
- 完整的字段和索引定义
- 复杂的表间关系管理
- 高效的查询性能
- 可扩展的架构设计

### 1.2 技术选型
- **主数据库**: SQLite（开发）/ PostgreSQL（生产推荐）
- **ORM框架**: Prisma
- **数据迁移**: Prisma Migrate
- **数据验证**: Zod + 数据库约束

### 1.3 设计原则
- **数据一致性**: 通过外键约束保证数据完整性
- **性能优化**: 合理的索引设计和查询优化
- **可扩展性**: 支持未来功能扩展的灵活结构
- **版本控制**: 内置版本管理和变更追踪

## 2. 数据库架构概览

### 2.1 核心实体关系图

```
Project (项目)
    ├── DatabaseTable (数据表)
    │   ├── DatabaseField (字段)
    │   │   └── FieldEnumValue (枚举值)
    │   ├── DatabaseIndex (索引)
    │   │   └── IndexField (索引字段)
    │   ├── TableStatistics (统计信息)
    │   └── TableRelationship (表关系)
    └── DataModelDocument (导入文档)
```

### 2.2 数据库模式图

```sql
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     Project     │────│ DatabaseTable   │────│ DatabaseField   │
│                 │    │                 │    │                 │
│ - id            │    │ - id            │    │ - id            │
│ - name          │    │ - projectId     │    │ - tableId       │
│ - description   │    │ - name          │    │ - name          │
│ - status        │    │ - displayName   │    │ - type          │
└─────────────────┘    │ - comment       │    │ - length        │
                       │ - engine        │    │ - nullable      │
                       │ - charset       │    │ - defaultValue  │
                       │ - status        │    │ - isPrimaryKey  │
                       │ - category      │    │ - comment       │
                       └─────────────────┘    └─────────────────┘
                              │                        │
                              │                        │
                       ┌─────────────────┐    ┌─────────────────┐
                       │ DatabaseIndex   │    │ FieldEnumValue  │
                       │                 │    │                 │
                       │ - id            │    │ - id            │
                       │ - tableId       │    │ - fieldId       │
                       │ - name          │    │ - value         │
                       │ - type          │    │ - label         │
                       │ - isUnique      │    │ - sortOrder     │
                       └─────────────────┘    └─────────────────┘
```

## 3. 详细表结构设计

### 3.1 项目相关表

#### 3.1.1 projects（项目表）
```sql
CREATE TABLE projects (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    base_url VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_project_status CHECK (status IN ('ACTIVE', 'ARCHIVED', 'DELETED'))
);

CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_created_at ON projects(created_at DESC);
```

**字段说明**：
- `id`: 项目唯一标识（UUID）
- `name`: 项目名称，不可重复
- `description`: 项目描述
- `status`: 项目状态（ACTIVE/ARCHIVED/DELETED）
- `base_url`: API测试基础URL
- `created_at/updated_at`: 时间戳

### 3.2 数据表相关表

#### 3.2.1 database_tables（数据表定义）
```sql
CREATE TABLE database_tables (
    id VARCHAR(36) PRIMARY KEY,
    project_id VARCHAR(36) NOT NULL,
    name VARCHAR(64) NOT NULL,
    display_name VARCHAR(100),
    comment TEXT,
    engine VARCHAR(20) NOT NULL DEFAULT 'InnoDB',
    charset VARCHAR(20) NOT NULL DEFAULT 'utf8mb4',
    collation VARCHAR(50) NOT NULL DEFAULT 'utf8mb4_unicode_ci',
    status VARCHAR(20) NOT NULL DEFAULT 'DRAFT',
    category VARCHAR(50),
    
    -- 扩展属性
    tablespace VARCHAR(64),
    auto_increment BIGINT,
    row_format VARCHAR(20),
    data_length BIGINT DEFAULT 0,
    index_length BIGINT DEFAULT 0,
    avg_row_length INTEGER DEFAULT 0,
    checksum BOOLEAN DEFAULT FALSE,
    
    -- 元数据
    created_by VARCHAR(36),
    last_modified_by VARCHAR(36),
    version INTEGER NOT NULL DEFAULT 1,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    UNIQUE(name, project_id),
    
    CONSTRAINT chk_table_status CHECK (status IN ('DRAFT', 'ACTIVE', 'DEPRECATED')),
    CONSTRAINT chk_table_engine CHECK (engine IN ('InnoDB', 'MyISAM', 'Memory', 'Archive')),
    CONSTRAINT chk_row_format CHECK (row_format IN ('DYNAMIC', 'FIXED', 'COMPRESSED', 'REDUNDANT', 'COMPACT'))
);

CREATE INDEX idx_database_tables_project ON database_tables(project_id);
CREATE INDEX idx_database_tables_status ON database_tables(status);
CREATE INDEX idx_database_tables_category ON database_tables(category);
CREATE INDEX idx_database_tables_updated ON database_tables(updated_at DESC);
```

**字段说明**：
- `id`: 表唯一标识
- `project_id`: 所属项目ID
- `name`: 表名（数据库中的实际表名）
- `display_name`: 显示名称（中文名）
- `comment`: 表注释说明
- `engine`: 存储引擎
- `charset/collation`: 字符集和排序规则
- `status`: 表状态（草稿/已创建/已废弃）
- `category`: 表分类（用户系统、订单系统等）
- `tablespace`: 表空间（PostgreSQL/Oracle）
- `auto_increment`: 自增起始值
- `row_format`: 行存储格式
- `data_length/index_length`: 数据和索引大小
- `version`: 版本号，每次结构变更递增

#### 3.2.2 database_fields（数据字段定义）
```sql
CREATE TABLE database_fields (
    id VARCHAR(36) PRIMARY KEY,
    table_id VARCHAR(36) NOT NULL,
    name VARCHAR(64) NOT NULL,
    type VARCHAR(50) NOT NULL,
    length INTEGER,
    precision INTEGER,
    scale INTEGER,
    nullable BOOLEAN NOT NULL DEFAULT TRUE,
    default_value TEXT,
    comment TEXT,
    is_primary_key BOOLEAN NOT NULL DEFAULT FALSE,
    is_auto_increment BOOLEAN NOT NULL DEFAULT FALSE,
    sort_order INTEGER NOT NULL DEFAULT 0,
    
    -- 字符串字段属性
    character_set VARCHAR(20),
    collation VARCHAR(50),
    
    -- 数值字段属性
    is_unsigned BOOLEAN NOT NULL DEFAULT FALSE,
    zerofill BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- 约束属性
    is_unique BOOLEAN NOT NULL DEFAULT FALSE,
    is_index BOOLEAN NOT NULL DEFAULT FALSE,
    check_constraint TEXT,
    
    -- 外键属性
    referenced_table_id VARCHAR(36),
    referenced_field_id VARCHAR(36),
    on_update VARCHAR(20) DEFAULT 'RESTRICT',
    on_delete VARCHAR(20) DEFAULT 'RESTRICT',
    
    -- 业务属性
    is_business_key BOOLEAN NOT NULL DEFAULT FALSE,
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    field_group VARCHAR(50),
    display_order INTEGER,
    
    -- 元数据
    created_by VARCHAR(36),
    last_modified_by VARCHAR(36),
    version INTEGER NOT NULL DEFAULT 1,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (table_id) REFERENCES database_tables(id) ON DELETE CASCADE,
    FOREIGN KEY (referenced_table_id) REFERENCES database_tables(id),
    FOREIGN KEY (referenced_field_id) REFERENCES database_fields(id),
    UNIQUE(name, table_id),
    
    CONSTRAINT chk_field_type CHECK (type IN (
        'VARCHAR', 'CHAR', 'TEXT', 'LONGTEXT', 'MEDIUMTEXT', 'TINYTEXT',
        'INT', 'TINYINT', 'SMALLINT', 'MEDIUMINT', 'BIGINT',
        'DECIMAL', 'NUMERIC', 'FLOAT', 'DOUBLE',
        'DATE', 'TIME', 'DATETIME', 'TIMESTAMP', 'YEAR',
        'BOOLEAN', 'BIT',
        'JSON', 'ENUM', 'SET',
        'BINARY', 'VARBINARY', 'BLOB', 'LONGBLOB', 'MEDIUMBLOB', 'TINYBLOB'
    )),
    CONSTRAINT chk_fk_action CHECK (
        on_update IN ('CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION')
        AND on_delete IN ('CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION')
    ),
    CONSTRAINT chk_precision_scale CHECK (
        (precision IS NULL OR precision > 0) 
        AND (scale IS NULL OR (scale >= 0 AND scale <= precision))
    )
);

CREATE INDEX idx_database_fields_table ON database_fields(table_id);
CREATE INDEX idx_database_fields_name ON database_fields(name);
CREATE INDEX idx_database_fields_type ON database_fields(type);
CREATE INDEX idx_database_fields_pk ON database_fields(is_primary_key) WHERE is_primary_key = TRUE;
CREATE INDEX idx_database_fields_fk ON database_fields(referenced_table_id) WHERE referenced_table_id IS NOT NULL;
CREATE INDEX idx_database_fields_sort ON database_fields(table_id, sort_order);
```

**字段说明**：
- `type`: 数据类型（VARCHAR、INT、DATETIME等）
- `length/precision/scale`: 长度、精度、标度
- `nullable`: 是否允许NULL值
- `default_value`: 默认值
- `is_primary_key/is_auto_increment`: 主键和自增属性
- `character_set/collation`: 字符集和排序规则
- `is_unsigned/zerofill`: 数值类型属性
- `check_constraint`: CHECK约束表达式
- `on_update/on_delete`: 外键约束行为
- `is_business_key`: 是否业务主键
- `field_group`: 字段分组（基础信息、扩展属性等）

#### 3.2.3 field_enum_values（字段枚举值）
```sql
CREATE TABLE field_enum_values (
    id VARCHAR(36) PRIMARY KEY,
    field_id VARCHAR(36) NOT NULL,
    value VARCHAR(100) NOT NULL,
    label VARCHAR(200),
    description TEXT,
    sort_order INTEGER NOT NULL DEFAULT 0,
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (field_id) REFERENCES database_fields(id) ON DELETE CASCADE,
    UNIQUE(field_id, value)
);

CREATE INDEX idx_field_enum_values_field ON field_enum_values(field_id);
CREATE INDEX idx_field_enum_values_sort ON field_enum_values(field_id, sort_order);
```

**用途说明**：
- 存储ENUM和SET类型字段的可选值
- 支持显示标签和描述
- 支持默认值设置
- 支持值的启用/禁用

### 3.3 索引管理表

#### 3.3.1 database_indexes（索引定义）
```sql
CREATE TABLE database_indexes (
    id VARCHAR(36) PRIMARY KEY,
    table_id VARCHAR(36) NOT NULL,
    name VARCHAR(64) NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'INDEX',
    is_unique BOOLEAN NOT NULL DEFAULT FALSE,
    comment TEXT,
    
    -- 扩展属性
    index_method VARCHAR(20) NOT NULL DEFAULT 'BTREE',
    is_visible BOOLEAN NOT NULL DEFAULT TRUE,
    compression VARCHAR(20),
    where_clause TEXT,
    
    -- 统计信息
    cardinality BIGINT,
    index_length BIGINT,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (table_id) REFERENCES database_tables(id) ON DELETE CASCADE,
    UNIQUE(name, table_id),
    
    CONSTRAINT chk_index_type CHECK (type IN ('PRIMARY', 'UNIQUE', 'INDEX', 'FULLTEXT', 'SPATIAL')),
    CONSTRAINT chk_index_method CHECK (index_method IN ('BTREE', 'HASH', 'GIST', 'GIN', 'BRIN'))
);

CREATE INDEX idx_database_indexes_table ON database_indexes(table_id);
CREATE INDEX idx_database_indexes_type ON database_indexes(type);
```

#### 3.3.2 index_fields（索引字段关联）
```sql
CREATE TABLE index_fields (
    index_id VARCHAR(36) NOT NULL,
    field_name VARCHAR(64) NOT NULL,
    sort_order INTEGER NOT NULL DEFAULT 0,
    direction VARCHAR(4) NOT NULL DEFAULT 'ASC',
    length INTEGER,
    
    FOREIGN KEY (index_id) REFERENCES database_indexes(id) ON DELETE CASCADE,
    PRIMARY KEY (index_id, field_name),
    
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);

CREATE INDEX idx_index_fields_sort ON index_fields(index_id, sort_order);
```

**设计说明**：
- 将索引字段独立为关系表，支持复合索引
- `sort_order`: 字段在索引中的顺序
- `direction`: 排序方向（ASC/DESC）
- `length`: 前缀索引长度（VARCHAR类型）

### 3.4 关系管理表

#### 3.4.1 table_relationships（表关系定义）
```sql
CREATE TABLE table_relationships (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100),
    description TEXT,
    
    from_table_id VARCHAR(36) NOT NULL,
    to_table_id VARCHAR(36) NOT NULL,
    from_field_id VARCHAR(36) NOT NULL,
    to_field_id VARCHAR(36) NOT NULL,
    
    relationship_type VARCHAR(20) NOT NULL DEFAULT 'ONE_TO_MANY',
    
    -- 外键约束行为
    on_update VARCHAR(20) NOT NULL DEFAULT 'RESTRICT',
    on_delete VARCHAR(20) NOT NULL DEFAULT 'RESTRICT',
    
    -- 业务属性
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    cascade_delete BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- 元数据
    created_by VARCHAR(36),
    last_modified_by VARCHAR(36),
    version INTEGER NOT NULL DEFAULT 1,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (from_table_id) REFERENCES database_tables(id) ON DELETE CASCADE,
    FOREIGN KEY (to_table_id) REFERENCES database_tables(id) ON DELETE CASCADE,
    FOREIGN KEY (from_field_id) REFERENCES database_fields(id),
    FOREIGN KEY (to_field_id) REFERENCES database_fields(id),
    
    CONSTRAINT chk_relationship_type CHECK (relationship_type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
    CONSTRAINT chk_relationship_action CHECK (
        on_update IN ('CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION')
        AND on_delete IN ('CASCADE', 'SET NULL', 'SET DEFAULT', 'RESTRICT', 'NO ACTION')
    ),
    CONSTRAINT chk_different_tables CHECK (from_table_id != to_table_id OR from_field_id != to_field_id)
);

CREATE INDEX idx_table_relationships_from ON table_relationships(from_table_id);
CREATE INDEX idx_table_relationships_to ON table_relationships(to_table_id);
CREATE INDEX idx_table_relationships_type ON table_relationships(relationship_type);
CREATE UNIQUE INDEX idx_table_relationships_unique ON table_relationships(from_table_id, from_field_id, to_table_id, to_field_id);
```

### 3.5 统计信息表

#### 3.5.1 table_statistics（表统计信息）
```sql
CREATE TABLE table_statistics (
    id VARCHAR(36) PRIMARY KEY,
    table_id VARCHAR(36) NOT NULL UNIQUE,
    
    -- 数据统计
    row_count BIGINT NOT NULL DEFAULT 0,
    data_size BIGINT NOT NULL DEFAULT 0,
    index_size BIGINT NOT NULL DEFAULT 0,
    avg_row_length INTEGER NOT NULL DEFAULT 0,
    
    -- 关系统计
    incoming_refs INTEGER NOT NULL DEFAULT 0,
    outgoing_refs INTEGER NOT NULL DEFAULT 0,
    
    -- 性能统计
    read_count BIGINT NOT NULL DEFAULT 0,
    write_count BIGINT NOT NULL DEFAULT 0,
    last_read_at TIMESTAMP,
    last_write_at TIMESTAMP,
    
    -- 更新信息
    last_analyzed TIMESTAMP,
    analyzed_by VARCHAR(36),
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (table_id) REFERENCES database_tables(id) ON DELETE CASCADE
);

CREATE INDEX idx_table_statistics_analyzed ON table_statistics(last_analyzed);
CREATE INDEX idx_table_statistics_size ON table_statistics(data_size DESC);
```

### 3.6 文档管理表

#### 3.6.1 data_model_documents（导入文档记录）
```sql
CREATE TABLE data_model_documents (
    id VARCHAR(36) PRIMARY KEY,
    project_id VARCHAR(36) NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    file_path VARCHAR(500),
    content TEXT NOT NULL,
    parse_status VARCHAR(20) NOT NULL DEFAULT 'PENDING',
    parse_error TEXT,
    language VARCHAR(20) NOT NULL DEFAULT 'markdown',
    
    -- 解析统计
    parsed_tables_count INTEGER DEFAULT 0,
    parsed_fields_count INTEGER DEFAULT 0,
    parse_duration_ms INTEGER,
    
    -- AI解析配置
    ai_provider VARCHAR(50),
    ai_model VARCHAR(100),
    parse_options JSON,
    
    imported_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    
    CONSTRAINT chk_parse_status CHECK (parse_status IN ('PENDING', 'PROCESSING', 'SUCCESS', 'FAILED')),
    CONSTRAINT chk_language CHECK (language IN ('markdown', 'sql', 'json', 'xml', 'excel', 'word'))
);

CREATE INDEX idx_data_model_documents_project ON data_model_documents(project_id);
CREATE INDEX idx_data_model_documents_status ON data_model_documents(parse_status);
CREATE INDEX idx_data_model_documents_imported ON data_model_documents(imported_at DESC);
```

### 3.7 审计和版本控制表

#### 3.7.1 model_change_log（变更日志）
```sql
CREATE TABLE model_change_log (
    id VARCHAR(36) PRIMARY KEY,
    table_id VARCHAR(36),
    field_id VARCHAR(36),
    index_id VARCHAR(36),
    relationship_id VARCHAR(36),
    
    change_type VARCHAR(20) NOT NULL,
    entity_type VARCHAR(20) NOT NULL,
    
    -- 变更内容
    before_data JSON,
    after_data JSON,
    change_summary TEXT,
    
    -- 操作信息
    operation VARCHAR(20) NOT NULL,
    operated_by VARCHAR(36),
    operation_reason TEXT,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_change_type CHECK (change_type IN ('CREATE', 'UPDATE', 'DELETE', 'RENAME', 'RESTRUCTURE')),
    CONSTRAINT chk_entity_type CHECK (entity_type IN ('TABLE', 'FIELD', 'INDEX', 'RELATIONSHIP')),
    CONSTRAINT chk_operation CHECK (operation IN ('CREATE', 'UPDATE', 'DELETE', 'RESTORE')),
    
    -- 至少要有一个实体ID
    CONSTRAINT chk_entity_reference CHECK (
        (table_id IS NOT NULL) OR 
        (field_id IS NOT NULL) OR 
        (index_id IS NOT NULL) OR 
        (relationship_id IS NOT NULL)
    )
);

CREATE INDEX idx_model_change_log_table ON model_change_log(table_id);
CREATE INDEX idx_model_change_log_type ON model_change_log(change_type);
CREATE INDEX idx_model_change_log_time ON model_change_log(created_at DESC);
CREATE INDEX idx_model_change_log_user ON model_change_log(operated_by);
```

## 4. 视图和存储过程

### 4.1 常用视图定义

#### 4.1.1 table_summary_view（表摘要视图）
```sql
CREATE VIEW table_summary_view AS
SELECT 
    t.id,
    t.project_id,
    t.name,
    t.display_name,
    t.comment,
    t.status,
    t.category,
    t.engine,
    
    -- 统计信息
    COUNT(f.id) as field_count,
    COUNT(i.id) as index_count,
    COALESCE(ts.row_count, 0) as row_count,
    COALESCE(ts.data_size, 0) as data_size,
    COALESCE(ts.incoming_refs, 0) + COALESCE(ts.outgoing_refs, 0) as relationship_count,
    
    -- 时间信息
    t.created_at,
    t.updated_at,
    ts.last_analyzed
    
FROM database_tables t
LEFT JOIN database_fields f ON t.id = f.table_id
LEFT JOIN database_indexes i ON t.id = i.table_id
LEFT JOIN table_statistics ts ON t.id = ts.table_id
GROUP BY t.id, t.project_id, t.name, t.display_name, t.comment, 
         t.status, t.category, t.engine, t.created_at, t.updated_at,
         ts.row_count, ts.data_size, ts.incoming_refs, ts.outgoing_refs, ts.last_analyzed;
```

#### 4.1.2 field_detail_view（字段详情视图）
```sql
CREATE VIEW field_detail_view AS
SELECT 
    f.id,
    f.table_id,
    f.name,
    f.type,
    f.length,
    f.precision,
    f.scale,
    f.nullable,
    f.default_value,
    f.comment,
    f.is_primary_key,
    f.is_auto_increment,
    f.is_unique,
    f.sort_order,
    
    -- 外键信息
    f.referenced_table_id,
    rt.name as referenced_table_name,
    rf.name as referenced_field_name,
    f.on_update,
    f.on_delete,
    
    -- 枚举值
    GROUP_CONCAT(ev.value ORDER BY ev.sort_order) as enum_values,
    
    f.created_at,
    f.updated_at
    
FROM database_fields f
LEFT JOIN database_tables rt ON f.referenced_table_id = rt.id
LEFT JOIN database_fields rf ON f.referenced_field_id = rf.id
LEFT JOIN field_enum_values ev ON f.id = ev.field_id AND ev.is_active = TRUE
GROUP BY f.id, f.table_id, f.name, f.type, f.length, f.precision, f.scale,
         f.nullable, f.default_value, f.comment, f.is_primary_key, f.is_auto_increment,
         f.is_unique, f.sort_order, f.referenced_table_id, rt.name, rf.name,
         f.on_update, f.on_delete, f.created_at, f.updated_at;
```

### 4.2 存储过程

#### 4.2.1 更新表统计信息
```sql
-- PostgreSQL版本
CREATE OR REPLACE FUNCTION update_table_statistics(p_table_id VARCHAR(36))
RETURNS VOID AS $$
DECLARE
    incoming_count INTEGER;
    outgoing_count INTEGER;
BEGIN
    -- 计算传入关系数量
    SELECT COUNT(*) INTO incoming_count
    FROM table_relationships
    WHERE to_table_id = p_table_id;
    
    -- 计算传出关系数量
    SELECT COUNT(*) INTO outgoing_count
    FROM table_relationships
    WHERE from_table_id = p_table_id;
    
    -- 更新统计信息
    INSERT INTO table_statistics (
        id, table_id, incoming_refs, outgoing_refs, last_analyzed
    )
    VALUES (
        gen_random_uuid(), p_table_id, incoming_count, outgoing_count, CURRENT_TIMESTAMP
    )
    ON CONFLICT (table_id) DO UPDATE SET
        incoming_refs = incoming_count,
        outgoing_refs = outgoing_count,
        last_analyzed = CURRENT_TIMESTAMP,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;
```

#### 4.2.2 生成CREATE TABLE语句
```sql
-- 简化版本，实际实现会在应用层
CREATE OR REPLACE FUNCTION generate_create_table_sql(p_table_id VARCHAR(36))
RETURNS TEXT AS $$
DECLARE
    table_info RECORD;
    field_info RECORD;
    sql_text TEXT;
BEGIN
    -- 获取表基础信息
    SELECT name, engine, charset, collation, comment
    INTO table_info
    FROM database_tables
    WHERE id = p_table_id;
    
    sql_text := 'CREATE TABLE `' || table_info.name || '` (' || CHR(10);
    
    -- 遍历字段生成定义
    FOR field_info IN
        SELECT name, type, length, nullable, default_value, is_primary_key, comment
        FROM database_fields
        WHERE table_id = p_table_id
        ORDER BY sort_order
    LOOP
        sql_text := sql_text || '  `' || field_info.name || '` ' || field_info.type;
        
        IF field_info.length IS NOT NULL THEN
            sql_text := sql_text || '(' || field_info.length || ')';
        END IF;
        
        IF NOT field_info.nullable THEN
            sql_text := sql_text || ' NOT NULL';
        END IF;
        
        IF field_info.default_value IS NOT NULL THEN
            sql_text := sql_text || ' DEFAULT ' || field_info.default_value;
        END IF;
        
        IF field_info.comment IS NOT NULL THEN
            sql_text := sql_text || ' COMMENT ''' || field_info.comment || '''';
        END IF;
        
        sql_text := sql_text || ',' || CHR(10);
    END LOOP;
    
    -- 移除最后的逗号并添加表定义结尾
    sql_text := RTRIM(sql_text, ',' || CHR(10)) || CHR(10) || 
                ') ENGINE=' || table_info.engine || 
                ' DEFAULT CHARSET=' || table_info.charset;
    
    IF table_info.comment IS NOT NULL THEN
        sql_text := sql_text || ' COMMENT=''' || table_info.comment || '''';
    END IF;
    
    sql_text := sql_text || ';';
    
    RETURN sql_text;
END;
$$ LANGUAGE plpgsql;
```

## 5. 索引优化策略

### 5.1 主要索引

#### 5.1.1 查询性能索引
```sql
-- 项目相关查询
CREATE INDEX idx_tables_project_status ON database_tables(project_id, status);
CREATE INDEX idx_tables_project_category ON database_tables(project_id, category);

-- 字段查询优化
CREATE INDEX idx_fields_table_sort ON database_fields(table_id, sort_order);
CREATE INDEX idx_fields_type_nullable ON database_fields(type, nullable);

-- 关系查询优化
CREATE INDEX idx_relationships_tables ON table_relationships(from_table_id, to_table_id);
CREATE INDEX idx_relationships_fields ON table_relationships(from_field_id, to_field_id);

-- 统计信息查询
CREATE INDEX idx_statistics_size_analyzed ON table_statistics(data_size DESC, last_analyzed);
```

#### 5.1.2 复合索引
```sql
-- 支持分页和排序的复合索引
CREATE INDEX idx_tables_project_status_updated ON database_tables(project_id, status, updated_at DESC);
CREATE INDEX idx_fields_table_pk_sort ON database_fields(table_id, is_primary_key, sort_order);
CREATE INDEX idx_change_log_table_time ON model_change_log(table_id, created_at DESC);
```

### 5.2 分区策略（适用于大数据量）

#### 5.2.1 按项目分区
```sql
-- PostgreSQL 分区表示例
CREATE TABLE model_change_log_partitioned (
    LIKE model_change_log INCLUDING ALL
) PARTITION BY HASH (project_id);

-- 创建分区
CREATE TABLE model_change_log_part_0 PARTITION OF model_change_log_partitioned
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE model_change_log_part_1 PARTITION OF model_change_log_partitioned
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
-- ... 其他分区
```

#### 5.2.2 按时间分区
```sql
-- 按年月分区变更日志
CREATE TABLE model_change_log_time_partitioned (
    LIKE model_change_log INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 按月创建分区
CREATE TABLE model_change_log_2025_01 PARTITION OF model_change_log_time_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

## 6. 数据完整性约束

### 6.1 引用完整性
```sql
-- 确保外键字段类型匹配
ALTER TABLE database_fields 
ADD CONSTRAINT chk_fk_field_type_match 
CHECK (
    referenced_field_id IS NULL OR 
    (SELECT type FROM database_fields rf WHERE rf.id = referenced_field_id) = type
);

-- 确保主键字段不能删除
ALTER TABLE database_fields
ADD CONSTRAINT chk_pk_field_no_delete
CHECK (is_primary_key = FALSE OR default_value IS NULL);
```

### 6.2 业务规则约束
```sql
-- 表中至少要有一个字段
CREATE OR REPLACE FUNCTION check_table_has_fields()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT COUNT(*) FROM database_fields WHERE table_id = OLD.table_id) <= 1 THEN
        RAISE EXCEPTION 'Table must have at least one field';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_check_table_fields_before_delete
    BEFORE DELETE ON database_fields
    FOR EACH ROW
    EXECUTE FUNCTION check_table_has_fields();

-- 主键字段必须非空
ALTER TABLE database_fields
ADD CONSTRAINT chk_pk_not_null
CHECK (NOT is_primary_key OR nullable = FALSE);

-- 自增字段必须是数值类型
ALTER TABLE database_fields
ADD CONSTRAINT chk_auto_increment_numeric
CHECK (NOT is_auto_increment OR type IN ('INT', 'BIGINT', 'SMALLINT', 'TINYINT'));
```

## 7. 数据迁移策略

### 7.1 版本升级脚本

#### 7.1.1 从v1.0到v2.0的迁移
```sql
-- 添加新字段（向后兼容）
ALTER TABLE database_tables 
ADD COLUMN tablespace VARCHAR(64),
ADD COLUMN auto_increment BIGINT,
ADD COLUMN row_format VARCHAR(20),
ADD COLUMN version INTEGER NOT NULL DEFAULT 1;

-- 创建新表
CREATE TABLE table_statistics (
    -- 完整定义见上文
);

-- 初始化统计数据
INSERT INTO table_statistics (id, table_id, row_count, data_size)
SELECT gen_random_uuid(), id, 0, 0
FROM database_tables;

-- 更新现有数据
UPDATE database_tables SET version = 1 WHERE version IS NULL;
```

#### 7.1.2 数据类型标准化
```sql
-- 标准化数据类型名称
UPDATE database_fields 
SET type = CASE 
    WHEN UPPER(type) = 'STRING' THEN 'VARCHAR'
    WHEN UPPER(type) = 'INTEGER' THEN 'INT'
    WHEN UPPER(type) = 'BOOL' THEN 'BOOLEAN'
    ELSE type
END;

-- 修复长度设置
UPDATE database_fields 
SET length = 255 
WHERE type = 'VARCHAR' AND length IS NULL;
```

### 7.2 数据备份和恢复

#### 7.2.1 备份策略
```sql
-- 创建备份表
CREATE TABLE database_tables_backup AS 
SELECT * FROM database_tables;

CREATE TABLE database_fields_backup AS 
SELECT * FROM database_fields;

-- 导出关键数据
COPY (
    SELECT t.name as table_name, f.name as field_name, 
           f.type, f.length, f.nullable, f.default_value
    FROM database_tables t
    JOIN database_fields f ON t.id = f.table_id
    ORDER BY t.name, f.sort_order
) TO '/backup/table_structure.csv' WITH CSV HEADER;
```

#### 7.2.2 恢复验证
```sql
-- 验证数据完整性
SELECT 
    'Missing fields' as issue_type,
    COUNT(*) as count
FROM database_tables t
LEFT JOIN database_fields f ON t.id = f.table_id
WHERE f.id IS NULL

UNION ALL

SELECT 
    'Orphaned fields' as issue_type,
    COUNT(*) as count
FROM database_fields f
LEFT JOIN database_tables t ON f.table_id = t.id
WHERE t.id IS NULL

UNION ALL

SELECT 
    'Invalid foreign keys' as issue_type,
    COUNT(*) as count
FROM database_fields f
WHERE f.referenced_table_id IS NOT NULL 
AND NOT EXISTS (
    SELECT 1 FROM database_tables rt 
    WHERE rt.id = f.referenced_table_id
);
```

## 8. 性能监控

### 8.1 查询性能监控

#### 8.1.1 慢查询识别
```sql
-- 创建查询性能日志表
CREATE TABLE query_performance_log (
    id VARCHAR(36) PRIMARY KEY,
    query_type VARCHAR(50) NOT NULL,
    table_ids TEXT,
    execution_time_ms INTEGER NOT NULL,
    row_count INTEGER,
    query_sql TEXT,
    execution_plan TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 监控视图
CREATE VIEW slow_queries_view AS
SELECT 
    query_type,
    AVG(execution_time_ms) as avg_time,
    MAX(execution_time_ms) as max_time,
    COUNT(*) as query_count,
    DATE_TRUNC('hour', created_at) as hour
FROM query_performance_log
WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
GROUP BY query_type, DATE_TRUNC('hour', created_at)
ORDER BY avg_time DESC;
```

#### 8.1.2 索引使用率统计
```sql
-- PostgreSQL版本
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_tup_read,
    idx_tup_fetch,
    CASE 
        WHEN idx_tup_read = 0 THEN 0
        ELSE ROUND(idx_tup_fetch::NUMERIC / idx_tup_read * 100, 2)
    END as hit_rate
FROM pg_stat_user_indexes
ORDER BY hit_rate ASC;
```

## 9. 扩展性考虑

### 9.1 多数据库支持

#### 9.1.1 数据库方言支持
```sql
-- 添加数据库类型字段
ALTER TABLE database_tables 
ADD COLUMN database_type VARCHAR(20) NOT NULL DEFAULT 'MySQL';

-- 支持的数据库类型
ALTER TABLE database_tables
ADD CONSTRAINT chk_database_type 
CHECK (database_type IN ('MySQL', 'PostgreSQL', 'SQLite', 'Oracle', 'SQL Server'));

-- 字段类型映射表
CREATE TABLE field_type_mapping (
    id VARCHAR(36) PRIMARY KEY,
    database_type VARCHAR(20) NOT NULL,
    standard_type VARCHAR(50) NOT NULL,
    native_type VARCHAR(50) NOT NULL,
    supports_length BOOLEAN DEFAULT FALSE,
    supports_precision BOOLEAN DEFAULT FALSE,
    max_length INTEGER,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 初始化映射数据
INSERT INTO field_type_mapping (id, database_type, standard_type, native_type, supports_length) VALUES
(gen_random_uuid(), 'MySQL', 'VARCHAR', 'VARCHAR', TRUE),
(gen_random_uuid(), 'PostgreSQL', 'VARCHAR', 'VARCHAR', TRUE),
(gen_random_uuid(), 'SQLite', 'VARCHAR', 'TEXT', FALSE),
(gen_random_uuid(), 'MySQL', 'INT', 'INT', FALSE),
(gen_random_uuid(), 'PostgreSQL', 'INT', 'INTEGER', FALSE),
(gen_random_uuid(), 'SQLite', 'INT', 'INTEGER', FALSE);
```

### 9.2 插件化架构支持

#### 9.2.1 扩展属性表
```sql
CREATE TABLE table_extensions (
    id VARCHAR(36) PRIMARY KEY,
    table_id VARCHAR(36) NOT NULL,
    extension_type VARCHAR(50) NOT NULL,
    extension_name VARCHAR(100) NOT NULL,
    extension_data JSON NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (table_id) REFERENCES database_tables(id) ON DELETE CASCADE,
    UNIQUE(table_id, extension_type, extension_name)
);

-- 示例：时序数据库扩展
INSERT INTO table_extensions (id, table_id, extension_type, extension_name, extension_data)
VALUES (
    gen_random_uuid(),
    'some-table-id',
    'TimeSeries',
    'InfluxDB',
    '{"measurement": "sensor_data", "tags": ["device_id", "location"], "retention_policy": "30d"}'
);
```

## 10. 总结

### 10.1 设计优势
- **完整性**: 涵盖数据模型管理的所有核心功能
- **扩展性**: 支持多种数据库类型和未来功能扩展
- **性能**: 合理的索引设计和查询优化
- **一致性**: 完善的约束和事务保证
- **可维护性**: 清晰的表结构和命名规范

### 10.2 最佳实践
- **定期统计更新**: 建议每日自动更新表统计信息
- **索引监控**: 定期检查索引使用情况，优化查询性能  
- **数据归档**: 对历史变更日志进行定期归档
- **备份策略**: 建立完整的数据备份和恢复机制
- **版本管理**: 严格的数据库版本升级流程

### 10.3 注意事项
- 根据实际数据量选择合适的数据库引擎
- 在生产环境中谨慎执行结构变更
- 定期检查和优化查询性能
- 保持良好的数据一致性和完整性

---

**文档版本**: v1.0  
**创建时间**: 2025-01-15  
**最后更新**: 2025-01-15  
**维护人员**: DevAPI团队